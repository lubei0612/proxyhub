{
  "id": "snapshot_1762777744423_3au457j69",
  "approvalId": "approval_1762777744395_1yoa7fcaa",
  "approvalTitle": "Security Hardening Tasks - Phase 3",
  "version": 1,
  "timestamp": "2025-11-10T12:29:04.423Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document\r\n\r\n## Phase 1: Foundation (P0 - Critical Security Fixes)\r\n\r\n- [ ] 1. Create ConfigValidator utility with schema validation\r\n  - Files: `backend/src/common/security/config-validator.ts`, `backend/src/common/security/validation-schemas.ts`\r\n  - Create ConfigValidator class with Joi schema validation for all environment variables\r\n  - Validate JWT_SECRET minimum length (32 chars), required database config, API keys\r\n  - Add graceful warnings for optional missing vars (email, Telegram)\r\n  - _Leverage: `@nestjs/config (ConfigService)`, `joi` package_\r\n  - _Requirements: R1 (Remove Hardcoded Secrets), R10 (Environment Validation)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Security Engineer with expertise in configuration management and validation | Task: Create a comprehensive ConfigValidator utility following requirements R1 and R10. Implement Joi schema validation for all environment variables, ensuring JWT_SECRET has minimum 32 character length, all required database configs are present, and API keys are validated. Handle optional variables gracefully with warnings. Files: backend/src/common/security/config-validator.ts and backend/src/common/security/validation-schemas.ts | Restrictions: Do not use default values for security-critical variables (JWT_SECRET, API keys), must throw clear error messages indicating which variable is missing or invalid, process must exit with code 1 on critical validation failure, do not bypass validation in any environment | Leverage: Existing @nestjs/config ConfigService, joi package for schema validation | Success: Application refuses to start without required environment variables, JWT_SECRET length is enforced, clear error messages guide operators to fix configuration issues, optional variables log warnings only. After implementation: Edit tasks.md to mark this task as [-] in progress, then implement the code. After completion, use log-implementation tool with detailed artifacts (functions, classes, validation schemas) and mark task as [x] completed._\r\n\r\n- [ ] 2. Integrate ConfigValidator into application bootstrap\r\n  - Files: `backend/src/main.ts`, `backend/src/app.module.ts`\r\n  - Call ConfigValidator.validateConfig() at the very start of bootstrap() before any other initialization\r\n  - Ensure app terminates with proper error logging if validation fails\r\n  - Add ConfigModule configuration with validated schema\r\n  - _Leverage: Existing ConfigModule setup in app.module.ts, ConfigValidator from task 1_\r\n  - _Requirements: R1 (Remove Hardcoded Secrets), R10 (Environment Validation)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with expertise in NestJS application bootstrapping | Task: Integrate ConfigValidator into application startup following requirements R1 and R10. Add validation call at the very beginning of bootstrap() in main.ts, before creating the app instance. Configure ConfigModule with validated schema. Files: backend/src/main.ts, backend/src/app.module.ts | Restrictions: Validation must happen before ANY other initialization, do not catch and suppress validation errors, ensure process exits cleanly with code 1 on failure, maintain existing ConfigModule configuration | Leverage: ConfigValidator from task 1, existing ConfigModule setup | Success: Application bootstrap validates configuration first, clear error messages on missing/invalid config, process exits properly on validation failure, all existing functionality remains intact. After implementation: Edit tasks.md to mark as [-] in progress, implement, log with artifacts (integration points, bootstrap sequence), mark as [x] complete._\r\n\r\n- [ ] 3. Remove hardcoded API key from Proxy985Service\r\n  - Files: `backend/src/modules/proxy985/proxy985.service.ts`\r\n  - Remove default value from apiKey initialization: change `|| 'ne_hj06qomI-...'` to throw error if missing\r\n  - Use ConfigService.getOrThrow('PROXY_985_API_KEY') instead\r\n  - Update constructor to inject ConfigService\r\n  - _Leverage: ConfigService from @nestjs/config_\r\n  - _Requirements: R1 (Remove Hardcoded Secrets)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with security focus | Task: Remove hardcoded API key default value from Proxy985Service following requirement R1. Replace `process.env.PROXY_985_API_KEY || 'default...'` with ConfigService.getOrThrow() call. Inject ConfigService via constructor. Files: backend/src/modules/proxy985/proxy985.service.ts | Restrictions: Do NOT provide any default value for API key, must throw clear error if PROXY_985_API_KEY is not configured, maintain all existing functionality, do not change API client behavior | Leverage: @nestjs/config ConfigService | Success: No hardcoded API key remains in code, service throws clear error when key is missing, existing 985Proxy integration works unchanged when key is properly configured. After implementation: Mark task [-] in progress, implement, log with artifacts (modified classes, removed hardcoded values), mark [x] complete._\r\n\r\n- [ ] 4. Remove default JWT secret from JwtStrategy\r\n  - Files: `backend/src/modules/auth/strategies/jwt.strategy.ts`, `backend/src/modules/auth/auth.module.ts`\r\n  - Remove default value from JWT_SECRET: change `|| 'proxyhub-super-secret-key...'` to ConfigService.getOrThrow\r\n  - Inject ConfigService into JwtStrategy constructor\r\n  - Update JwtModule registration to use ConfigService\r\n  - _Leverage: ConfigService, existing JwtModule configuration_\r\n  - _Requirements: R1 (Remove Hardcoded Secrets)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Security Engineer with JWT expertise | Task: Remove hardcoded JWT secret default value from JwtStrategy following requirement R1. Replace default secret with ConfigService.getOrThrow('JWT_SECRET'). Update JwtStrategy constructor and JwtModule registration in auth.module.ts. Files: backend/src/modules/auth/strategies/jwt.strategy.ts, backend/src/modules/auth/auth.module.ts | Restrictions: Do NOT provide default value for JWT_SECRET, must throw error if not configured, maintain existing authentication flow, ensure token generation and validation still work | Leverage: ConfigService, existing JwtModule configuration | Success: No default JWT secret in code, application requires explicit JWT_SECRET configuration, authentication works correctly when properly configured. After implementation: Mark [-], implement, log with artifacts (strategy modifications, module configuration), mark [x]._\r\n\r\n- [ ] 5. Create PasswordValidator with strong password requirements\r\n  - Files: `backend/src/common/security/password-validator.ts`, `backend/src/common/security/weak-passwords.ts`\r\n  - Create IsStrongPassword decorator using class-validator\r\n  - Implement validation: minLength 8, at least 1 uppercase, 1 lowercase, 1 number\r\n  - Add weak password blocklist (123456, password, qwerty, etc.)\r\n  - Export validatePasswordStrength() utility function\r\n  - _Leverage: class-validator package_\r\n  - _Requirements: R2 (Strong Password Policy)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Security Developer with expertise in password validation | Task: Create comprehensive password validation utility following requirement R2. Implement IsStrongPassword decorator with rules: minimum 8 characters, at least 1 uppercase letter, 1 lowercase letter, 1 number. Include blocklist of common weak passwords. Files: backend/src/common/security/password-validator.ts, backend/src/common/security/weak-passwords.ts | Restrictions: Must provide specific error messages for each failed requirement, do not weaken validation rules, blocklist must include at least 100 common weak passwords, validation must be efficient (<10ms) | Leverage: class-validator decorators, existing validation framework | Success: Decorator properly validates password strength, specific error messages guide users, weak passwords are rejected, validation is fast and reliable. After implementation: Mark [-], implement, log with artifacts (functions, decorators, validation rules), mark [x]._\r\n\r\n- [ ] 6. Apply password validation to authentication DTOs\r\n  - Files: `backend/src/modules/auth/dto/register.dto.ts`, `backend/src/modules/auth/dto/change-password.dto.ts`\r\n  - Replace @MinLength(8) with @IsStrongPassword() decorator\r\n  - Add @IsNotCommonPassword() if available\r\n  - Update error messages to reflect new requirements\r\n  - _Leverage: PasswordValidator from task 5, existing DTO structure_\r\n  - _Requirements: R2 (Strong Password Policy)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with DTO validation expertise | Task: Apply strong password validation to authentication DTOs following requirement R2. Replace simple @MinLength(8) with @IsStrongPassword() decorator in RegisterDto and ChangePasswordDto. Files: backend/src/modules/auth/dto/register.dto.ts, backend/src/modules/auth/dto/change-password.dto.ts (create if not exists) | Restrictions: Must maintain existing DTO structure, do not break existing API contracts, ensure validation errors are user-friendly, apply to ALL password input points | Leverage: PasswordValidator from task 5, existing validation pipe | Success: All password inputs require strong passwords, clear validation messages, registration and password change flows work with new validation. After implementation: Mark [-], implement, log with artifacts (modified DTOs, applied decorators), mark [x]._\r\n\r\n- [ ] 7. Configure Redis-backed rate limiting with ThrottlerModule\r\n  - Files: `backend/src/app.module.ts`, `backend/src/common/guards/redis-throttler-storage.ts`\r\n  - Create RedisThrottlerStorage implementing ThrottlerStorage interface\r\n  - Update ThrottlerModule configuration to use Redis storage\r\n  - Configure global rate limits: 100 requests per 60 seconds\r\n  - _Leverage: Existing Redis client in app.module.ts, @nestjs/throttler_\r\n  - _Requirements: R3 (Rate Limiting Protection)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with Redis and rate limiting expertise | Task: Configure Redis-backed distributed rate limiting following requirement R3. Create RedisThrottlerStorage implementing ThrottlerStorage interface, integrate with existing Redis client. Update ThrottlerModule configuration. Files: backend/src/app.module.ts, backend/src/common/guards/redis-throttler-storage.ts | Restrictions: Must use existing Redis client from app.module.ts, do not create new Redis connections, ensure rate limits are distributed across instances, maintain sub-5ms overhead | Leverage: Existing Redis client, @nestjs/throttler ThrottlerModule | Success: Rate limiting uses Redis for distributed state, requests are limited globally across all server instances, minimal performance impact (<5ms per request). After implementation: Mark [-], implement, log with artifacts (classes, Redis integration, throttler config), mark [x]._\r\n\r\n- [ ] 8. Apply strict rate limiting to authentication endpoints\r\n  - Files: `backend/src/modules/auth/auth.controller.ts`\r\n  - Add @Throttle() decorator to login endpoint: 5 requests per 15 minutes\r\n  - Add @Throttle() decorator to send-code endpoint: 3 requests per 60 minutes per email\r\n  - Add @Throttle() decorator to register endpoint: 10 requests per 60 minutes\r\n  - Log rate limit violations with IP and user context\r\n  - _Leverage: ThrottlerGuard, Redis storage from task 7_\r\n  - _Requirements: R3 (Rate Limiting Protection)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Security Engineer with API protection expertise | Task: Apply strict rate limiting to authentication endpoints following requirement R3. Add @Throttle decorators: login (5/15min), send-code (3/60min), register (10/60min). Add logging for violations. Files: backend/src/modules/auth/auth.controller.ts | Restrictions: Must not break existing authentication flow, rate limits apply per IP address, must track by email for send-code endpoint, ensure rate limit errors include retry-after information | Leverage: ThrottlerGuard from @nestjs/throttler, Redis storage from task 7 | Success: Authentication endpoints have appropriate rate limits, brute force attacks are prevented, users receive clear error messages with retry timeframes, violations are logged. After implementation: Mark [-], implement, log with artifacts (applied guards, rate limit configurations), mark [x]._\r\n\r\n## Phase 2: Protection Layers (P1 - High Priority)\r\n\r\n- [ ] 9. Create AllExceptionsFilter with sensitive data sanitization\r\n  - Files: `backend/src/common/filters/all-exceptions.filter.ts`, `backend/src/common/exceptions/exception-mapper.ts`\r\n  - Create @Catch() filter implementing ExceptionFilter interface\r\n  - Map exceptions to appropriate HTTP status codes and error responses\r\n  - Sanitize error messages (hide stack traces in production, remove sensitive data)\r\n  - Return standardized format: { statusCode, message, errorCode, timestamp, path }\r\n  - _Leverage: Existing error code constants from common/constants/error-codes.ts_\r\n  - _Requirements: R4 (Global Exception Filter)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with exception handling expertise | Task: Create comprehensive global exception filter following requirement R4. Implement AllExceptionsFilter with @Catch() decorator, map all exception types to appropriate responses, sanitize sensitive data. Files: backend/src/common/filters/all-exceptions.filter.ts, backend/src/common/exceptions/exception-mapper.ts | Restrictions: Must catch ALL exception types, hide stack traces in production environment, do not expose internal implementation details, maintain existing error code constants | Leverage: Existing error codes from common/constants/error-codes.ts | Success: All exceptions are caught and formatted consistently, sensitive data is sanitized, stack traces hidden in production, error responses are user-friendly. After implementation: Mark [-], implement, log with artifacts (filter class, exception mapper, response formats), mark [x]._\r\n\r\n- [ ] 10. Register AllExceptionsFilter globally in main.ts\r\n  - Files: `backend/src/main.ts`\r\n  - Register AllExceptionsFilter using app.useGlobalFilters()\r\n  - Ensure filter is registered after ValidationPipe\r\n  - Test that custom exceptions are properly caught and formatted\r\n  - _Leverage: AllExceptionsFilter from task 9_\r\n  - _Requirements: R4 (Global Exception Filter)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with NestJS application configuration expertise | Task: Register AllExceptionsFilter globally in application bootstrap following requirement R4. Add filter registration after ValidationPipe. Files: backend/src/main.ts | Restrictions: Filter must be registered globally to catch all exceptions, maintain existing middleware order, do not interfere with existing error handling, ensure filter is active for all routes | Leverage: AllExceptionsFilter from task 9, existing application bootstrap | Success: Global exception filter is active for all requests, all exceptions are caught and formatted, existing functionality remains intact, error responses are consistent. After implementation: Mark [-], implement, log with artifacts (global filter registration, bootstrap configuration), mark [x]._\r\n\r\n- [ ] 11. Add input length validation to all DTOs\r\n  - Files: `backend/src/modules/auth/dto/*.dto.ts`, `backend/src/modules/user/dto/*.dto.ts`, `backend/src/modules/admin/dto/*.dto.ts`\r\n  - Add @MaxLength(255) to all email fields\r\n  - Add @MaxLength(100) to all nickname/name fields\r\n  - Add @MaxLength(1000) to all free-text fields (descriptions, notes)\r\n  - Add @MaxLength(500) to all address fields\r\n  - _Leverage: class-validator @MaxLength decorator_\r\n  - _Requirements: R5 (Input Length Validation)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with data validation expertise | Task: Add maximum length validation to all DTOs following requirement R5. Apply @MaxLength decorators: email (255), nickname (100), free-text (1000), addresses (500). Files: backend/src/modules/auth/dto/*.dto.ts, backend/src/modules/user/dto/*.dto.ts, backend/src/modules/admin/dto/*.dto.ts | Restrictions: Must not break existing API contracts, validation must apply to ALL input fields, error messages must specify which field and limit, maintain backward compatibility | Leverage: class-validator @MaxLength decorator, existing validation pipeline | Success: All text inputs have appropriate length limits, database overflow attacks are prevented, validation errors are clear and specific. After implementation: Mark [-], implement, log with artifacts (modified DTOs, applied length validators), mark [x]._\r\n\r\n- [ ] 12. Create TransactionWrapper utility for safe database operations\r\n  - Files: `backend/src/common/database/transaction-wrapper.ts`, `backend/src/common/database/transaction-options.ts`\r\n  - Create TransactionWrapper class with execute() method\r\n  - Support configurable isolation levels (READ_COMMITTED, SERIALIZABLE)\r\n  - Auto-rollback on errors with detailed logging\r\n  - Return typed results from transaction\r\n  - _Leverage: TypeORM DataSource and EntityManager_\r\n  - _Requirements: R6 (Database Transaction Safety)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with database transaction expertise | Task: Create comprehensive transaction wrapper utility following requirement R6. Implement TransactionWrapper class with automatic rollback, configurable isolation levels, error logging. Files: backend/src/common/database/transaction-wrapper.ts, backend/src/common/database/transaction-options.ts | Restrictions: Must use existing TypeORM DataSource, automatically rollback on any error, support configurable isolation levels, add <50ms overhead, log transaction context on errors | Leverage: TypeORM DataSource and EntityManager | Success: Transaction wrapper simplifies safe database operations, automatic rollback on errors, configurable isolation levels work correctly, minimal performance overhead. After implementation: Mark [-], implement, log with artifacts (classes, transaction utilities, error handling), mark [x]._\r\n\r\n- [ ] 13. Apply TransactionWrapper to user balance operations\r\n  - Files: `backend/src/modules/user/user.service.ts`, `backend/src/modules/billing/billing.service.ts`\r\n  - Wrap balance deduction operations in TransactionWrapper.execute()\r\n  - Use SERIALIZABLE isolation level for balance operations\r\n  - Add balance checks within transaction (SELECT FOR UPDATE pattern)\r\n  - Ensure proxy purchase and balance deduction are atomic\r\n  - _Leverage: TransactionWrapper from task 12, existing balance logic_\r\n  - _Requirements: R6 (Database Transaction Safety)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with financial transaction expertise | Task: Apply transaction safety to balance operations following requirement R6. Wrap balance deductions in TransactionWrapper with SERIALIZABLE isolation, implement SELECT FOR UPDATE pattern. Files: backend/src/modules/user/user.service.ts, backend/src/modules/billing/billing.service.ts | Restrictions: Must prevent race conditions, ensure balance never goes negative, maintain atomicity between proxy purchase and payment, add row-level locking, maintain existing API contracts | Leverage: TransactionWrapper from task 12, existing balance deduction logic | Success: Concurrent balance operations are safe, no race conditions occur, balance accuracy is guaranteed, operations are atomic. After implementation: Mark [-], implement, log with artifacts (transactional operations, isolation levels, locking), mark [x]._\r\n\r\n- [ ] 14. Configure Helmet middleware for security headers\r\n  - Files: `backend/src/main.ts`, `backend/src/common/security/helmet-config.ts`\r\n  - Install helmet package: `npm install helmet`\r\n  - Create HelmetConfigurer.getConfig() with secure defaults\r\n  - Apply helmet middleware in main.ts before CORS\r\n  - Configure: X-Frame-Options, X-Content-Type-Options, HSTS, disable X-Powered-By\r\n  - _Leverage: helmet package_\r\n  - _Requirements: R8 (Security Headers and CORS)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Security Engineer with web security expertise | Task: Configure Helmet middleware for security headers following requirement R8. Install helmet, create configuration, apply in main.ts. Set secure headers: X-Frame-Options (DENY), X-Content-Type-Options (nosniff), HSTS, disable X-Powered-By. Files: backend/src/main.ts, backend/src/common/security/helmet-config.ts | Restrictions: Must apply helmet before CORS configuration, use secure defaults appropriate for API usage, do not break existing CORS functionality, ensure CSP allows API operations | Leverage: helmet npm package | Success: Security headers are properly set on all responses, X-Powered-By is removed, HSTS is enabled, content type sniffing is prevented. After implementation: Mark [-], implement, log with artifacts (helmet configuration, applied middleware), mark [x]._\r\n\r\n- [ ] 15. Create environment-based CORS configuration\r\n  - Files: `backend/src/main.ts`, `backend/src/common/security/cors-config.ts`\r\n  - Create EnhancedCorsOptions.getOptions() that reads CORS_ORIGINS from env\r\n  - Development: Allow localhost origins (existing behavior)\r\n  - Production: Read comma-separated CORS_ORIGINS environment variable\r\n  - Add origin validation to prevent configuration errors\r\n  - _Leverage: Existing CORS setup in main.ts, ConfigService_\r\n  - _Requirements: R8 (Security Headers and CORS)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with CORS and security configuration expertise | Task: Create environment-based CORS configuration following requirement R8. Implement EnhancedCorsOptions that uses env vars in production, localhost in dev. Add origin validation. Files: backend/src/main.ts, backend/src/common/security/cors-config.ts | Restrictions: Must not break existing CORS behavior in development, production must require explicit CORS_ORIGINS configuration, validate origin format, maintain credentials support for authenticated endpoints | Leverage: Existing CORS setup, ConfigService for environment detection | Success: CORS is environment-aware, production requires explicit configuration, development remains convenient, origin validation prevents misconfigurations. After implementation: Mark [-], implement, log with artifacts (CORS configuration, environment handling), mark [x]._\r\n\r\n## Phase 3: Observability & Quality (P2 - Technical Debt)\r\n\r\n- [ ] 16. Create LoggingSanitizer utility for sensitive data removal\r\n  - Files: `backend/src/common/security/logging-sanitizer.ts`, `backend/src/common/security/sensitive-fields.ts`\r\n  - Create LoggingSanitizer.sanitize() method that recursively scans objects\r\n  - Redact sensitive fields: password, token, apiKey, creditCard, secret, authorization\r\n  - Mask JWT tokens (show only last 4 characters)\r\n  - Export list of sensitive field names for configuration\r\n  - _Leverage: None (pure utility)_\r\n  - _Requirements: R9 (Sensitive Data Logging Filter)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Security Developer with logging and data sanitization expertise | Task: Create comprehensive logging sanitizer following requirement R9. Implement recursive object sanitization, redact sensitive fields, mask tokens. Files: backend/src/common/security/logging-sanitizer.ts, backend/src/common/security/sensitive-fields.ts | Restrictions: Must handle nested objects and arrays, sanitization must be non-destructive (return copy), add <2ms overhead per log, handle circular references, mask but don't completely remove JWT tokens | Leverage: None - pure TypeScript utility | Success: Sensitive data is properly redacted from logs, JWT tokens are masked, nested objects are handled, no performance issues. After implementation: Mark [-], implement, log with artifacts (sanitizer functions, field lists, masking strategies), mark [x]._\r\n\r\n- [ ] 17. Integrate LoggingSanitizer into NestJS Logger\r\n  - Files: `backend/src/common/logger/sanitized-logger.service.ts`\r\n  - Create SanitizedLogger extending NestJS Logger\r\n  - Override log(), error(), warn(), debug() methods to sanitize data\r\n  - Automatically sanitize all logged objects and error messages\r\n  - Export as injectable service for dependency injection\r\n  - _Leverage: NestJS Logger, LoggingSanitizer from task 16_\r\n  - _Requirements: R9 (Sensitive Data Logging Filter)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with NestJS logging expertise | Task: Create SanitizedLogger service that integrates sanitization into logging following requirement R9. Extend NestJS Logger, override methods to use LoggingSanitizer. Files: backend/src/common/logger/sanitized-logger.service.ts | Restrictions: Must maintain same Logger API, sanitize all object parameters, preserve log levels and formatting, do not sanitize simple strings unless they contain sensitive patterns, maintain performance | Leverage: NestJS Logger class, LoggingSanitizer from task 16 | Success: All logs are automatically sanitized, sensitive data never appears in logs, Logger API remains compatible, no breaking changes. After implementation: Mark [-], implement, log with artifacts (logger service, integration with sanitizer), mark [x]._\r\n\r\n- [ ] 18. Write unit tests for security utilities\r\n  - Files: `backend/src/common/security/__tests__/config-validator.spec.ts`, `backend/src/common/security/__tests__/password-validator.spec.ts`, `backend/src/common/security/__tests__/logging-sanitizer.spec.ts`\r\n  - ConfigValidator tests: valid config, missing JWT_SECRET, weak JWT_SECRET, missing database config\r\n  - PasswordValidator tests: strong password accepted, weak passwords rejected, specific error messages\r\n  - LoggingSanitizer tests: password redaction, JWT masking, nested objects, circular references\r\n  - Target: 80%+ coverage for security module\r\n  - _Leverage: Jest testing framework, existing test patterns_\r\n  - _Requirements: R7 (Unit Tests)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with unit testing expertise | Task: Create comprehensive unit tests for security utilities following requirement R7. Write tests for ConfigValidator, PasswordValidator, LoggingSanitizer covering success and failure scenarios. Files: backend/src/common/security/__tests__/*.spec.ts | Restrictions: Must test both positive and negative cases, achieve 80%+ code coverage for security module, use proper mocking for external dependencies, tests must be isolated and repeatable | Leverage: Jest framework, existing test utilities | Success: All security utilities have comprehensive test coverage, edge cases are covered, tests run fast and reliably, 80%+ coverage achieved. After implementation: Mark [-], implement, log with artifacts (test files, coverage reports, test scenarios), mark [x]._\r\n\r\n- [ ] 19. Write unit tests for exception filter and guards\r\n  - Files: `backend/src/common/filters/__tests__/all-exceptions.filter.spec.ts`, `backend/src/common/guards/__tests__/redis-throttler-storage.spec.ts`\r\n  - AllExceptionsFilter tests: HttpException formatting, generic Error handling, stack trace hiding in production\r\n  - RedisThrottlerStorage tests: rate limit enforcement, TTL expiry, distributed state management\r\n  - Mock Redis client and exception contexts\r\n  - _Leverage: Jest, NestJS testing utilities_\r\n  - _Requirements: R7 (Unit Tests)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with NestJS testing expertise | Task: Create unit tests for exception filter and rate limiting following requirement R7. Test AllExceptionsFilter exception handling and RedisThrottlerStorage rate limiting. Files: backend/src/common/filters/__tests__/all-exceptions.filter.spec.ts, backend/src/common/guards/__tests__/redis-throttler-storage.spec.ts | Restrictions: Must mock Redis client and execution contexts, test all exception types, verify rate limit state management, ensure tests don't depend on external services | Leverage: Jest, @nestjs/testing utilities, Redis mocks | Success: Exception filter handles all error types correctly, rate limiting logic is verified, Redis integration is properly tested with mocks. After implementation: Mark [-], implement, log with artifacts (test files, mock strategies, test coverage), mark [x]._\r\n\r\n- [ ] 20. Write integration tests for authentication with rate limiting\r\n  - Files: `backend/test/auth.e2e-spec.ts`\r\n  - Test complete authentication flow: registration with strong password requirement\r\n  - Test login rate limiting: verify 429 response after 5 failed attempts\r\n  - Test verification code rate limiting: verify 429 after 3 requests\r\n  - Test transaction safety: concurrent balance operations\r\n  - _Leverage: Supertest for HTTP testing, existing test database setup_\r\n  - _Requirements: R7 (Unit Tests)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with end-to-end testing expertise | Task: Create integration tests for authentication flows with security features following requirement R7. Test registration with password validation, login rate limiting, verification code limits, transaction safety. Files: backend/test/auth.e2e-spec.ts | Restrictions: Must use test database, clean up test data after each test, tests must be idempotent and isolated, use realistic scenarios, verify actual HTTP responses and rate limit headers | Leverage: Supertest for HTTP requests, existing test database setup | Success: All security features are tested in realistic scenarios, rate limiting is verified end-to-end, password validation is confirmed, transaction safety is validated. After implementation: Mark [-], implement, log with artifacts (test scenarios, integration test patterns), mark [x]._\r\n\r\n## Post-Implementation Tasks\r\n\r\n- [ ] 21. Update .env.example with all required security variables\r\n  - Files: `.env.example`, `docs/ENVIRONMENT_VARIABLES.md`\r\n  - Add comprehensive comments for each security variable\r\n  - Document: JWT_SECRET requirements (32+ chars), API key formats, CORS_ORIGINS format\r\n  - Add example values (clearly marked as examples, not for production)\r\n  - Create documentation file explaining each variable's purpose\r\n  - _Leverage: Existing .env.example_\r\n  - _Requirements: R1 (Remove Hardcoded Secrets), R10 (Environment Validation)_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: DevOps Engineer with documentation expertise | Task: Update environment variable templates and documentation following requirements R1 and R10. Add comprehensive .env.example with comments, create detailed documentation for each security variable. Files: .env.example, docs/ENVIRONMENT_VARIABLES.md | Restrictions: Must NOT include real secrets even as examples, clearly mark all values as examples, document requirements for each variable (length, format), make it easy for new developers to configure | Leverage: Existing .env.example structure | Success: .env.example is comprehensive and well-documented, every required variable is listed, developers can easily configure new environments, security requirements are clear. After implementation: Mark [-], implement, log with artifacts (documentation files, example configurations), mark [x]._\r\n\r\n- [ ] 22. Create security configuration migration guide\r\n  - Files: `docs/SECURITY_MIGRATION_GUIDE.md`\r\n  - Document step-by-step migration from current setup to hardened version\r\n  - Include: generating secure JWT_SECRET, configuring rate limits, setting up CORS\r\n  - Add rollback procedures in case of issues\r\n  - Provide troubleshooting section for common configuration errors\r\n  - _Leverage: All previous implementation tasks_\r\n  - _Requirements: All_\r\n  - _Prompt: Implement the task for spec security-hardening, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer with security expertise | Task: Create comprehensive migration guide for security hardening covering all requirements. Document migration steps, configuration generation, rollback procedures, troubleshooting. Files: docs/SECURITY_MIGRATION_GUIDE.md | Restrictions: Must cover all security changes, provide concrete examples, include rollback plan, address common pitfalls, make it accessible for DevOps teams | Leverage: Knowledge from all previous implementation tasks | Success: Migration guide is complete and clear, operators can follow it step-by-step, rollback procedures are documented, troubleshooting covers common issues. After implementation: Mark [-], implement, log with artifacts (documentation, migration steps, troubleshooting guides), mark [x]._\r\n\r\n## Task Summary\r\n\r\n**Total Tasks**: 22\r\n\r\n**By Priority:**\r\n- P0 (Critical): Tasks 1-8 (8 tasks)\r\n- P1 (High): Tasks 9-15 (7 tasks)\r\n- P2 (Technical Debt): Tasks 16-20 (5 tasks)\r\n- Documentation: Tasks 21-22 (2 tasks)\r\n\r\n**Estimated Total Effort**: 45-50 hours\r\n\r\n**Dependencies:**\r\n- Tasks 1-2 must be completed before task 3-4\r\n- Task 5 must be completed before task 6\r\n- Task 7 must be completed before task 8\r\n- Task 9 must be completed before task 10\r\n- Task 12 must be completed before task 13\r\n- Task 16 must be completed before task 17\r\n- All implementation tasks should be completed before tasks 21-22\r\n\r\n",
  "fileStats": {
    "size": 35257,
    "lines": 244,
    "lastModified": "2025-11-10T12:28:48.884Z"
  },
  "comments": []
}